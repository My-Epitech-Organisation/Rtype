name: ðŸš€ R-Type Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

  workflow_call:
    inputs:
      source_run_id:
        description: 'Run ID of the CI workflow that produced artifacts'
        required: false
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'push' || github.event.workflow_run.conclusion == 'success' }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Check branch for manual release
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ "${{ github.ref_name }}" != "main" ]; then
            echo "âŒ Manual releases can only be triggered from the main branch"
            echo "Current branch: ${{ github.ref_name }}"
            exit 1
          fi

      - name: Determine context
        id: ctx
        run: |
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "branch=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
            echo "sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ inputs.source_run_id }}" ]; then
            # workflow_call path: caller must pass the CI run that built artifacts
            echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "run_id=${{ inputs.source_run_id }}" >> $GITHUB_OUTPUT
          else
            echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            # For manual dispatch: find the latest successful CI run on the same branch
            LATEST_CI_RUN=$(gh run list --repo "${{ github.repository }}" --workflow ci.yml --branch "${{ github.ref_name }}" --status success --json databaseId --limit 1 -q '.[0].databaseId')
            if [ -z "$LATEST_CI_RUN" ]; then
              echo "âŒ Error: No successful CI runs found on branch '${{ github.ref_name }}'. Please run the CI workflow first."
              exit 1
            fi
            echo "run_id=$LATEST_CI_RUN" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.ctx.outputs.sha }}
          fetch-depth: 0
          fetch-tags: true

      - name: Get latest release
        id: latest_release
        run: |
          git fetch --tags --force

          LATEST_TAG=$(git tag -l 'v*' | sort -V | tail -n 1)

          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi

          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest release: $LATEST_TAG"
          echo "All tags found:"
          git tag -l 'v*' | sort -V

      - name: Calculate next version
        id: version
        run: |
          LATEST_TAG="${{ steps.latest_release.outputs.latest_tag }}"
          BRANCH="${{ steps.ctx.outputs.branch }}"
          EVENT_NAME="${{ github.event_name }}"

          VERSION="${LATEST_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          echo "Current version: $MAJOR.$MINOR.$PATCH"
          echo "Branch: $BRANCH"
          echo "Event: $EVENT_NAME"

          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            NEW_MAJOR=$((MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
            PRERELEASE=false
            TAG_SUFFIX="release - main"
          elif [ "$BRANCH" = "main" ]; then
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
            PRERELEASE=true
            TAG_SUFFIX="main"
          elif [ "$BRANCH" = "dev" ]; then
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$MINOR
            NEW_PATCH=$((PATCH + 1))
            PRERELEASE=true
            TAG_SUFFIX="dev"
          else
            echo "Unsupported branch for release: $BRANCH"
            exit 1
          fi

          NEW_VERSION="v$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT
          echo "tag_suffix=$TAG_SUFFIX" >> $GITHUB_OUTPUT
      - name: Debug context
        run: |
          echo "=== Release Context Debug ==="
          echo "Run ID: ${{ steps.ctx.outputs.run_id }}"
          echo "Branch: ${{ steps.ctx.outputs.branch }}"
          echo "SHA: ${{ steps.ctx.outputs.sha }}"
          echo "Event: ${{ github.event_name }}"
          echo "inputs.source_run_id: ${{ inputs.source_run_id }}"
          echo "github.run_id: ${{ github.run_id }}"

      - name: Download Linux client artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          run_id: ${{ steps.ctx.outputs.run_id }}
          name: r-type_client-ubuntu-latest
          path: ./artifacts/linux-client

      - name: Download Windows client artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          run_id: ${{ steps.ctx.outputs.run_id }}
          name: r-type_client-windows-latest
          path: ./artifacts/windows-client

      - name: Download Linux server artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          run_id: ${{ steps.ctx.outputs.run_id }}
          name: r-type_server-ubuntu-latest
          path: ./artifacts/linux-server

      - name: Download Windows server artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          run_id: ${{ steps.ctx.outputs.run_id }}
          name: r-type_server-windows-latest
          path: ./artifacts/windows-server

      - name: List downloaded artifacts
        run: |
          echo "=== Downloaded Artifacts ==="
          find artifacts -type f -o -type d | sort || echo "No artifacts found"

      - name: Validate downloaded artifacts
        run: |
          echo "ðŸ” Validating downloaded artifacts..."
          echo "Artifact directory structure:"
          find artifacts -type f

          MISSING=0

          if [ ! -f "artifacts/linux-client/r-type_client" ]; then
            echo "âŒ Missing Linux client executable (expected: artifacts/linux-client/r-type_client)"
            MISSING=1
          else
            echo "âœ… Found Linux client"
          fi

          if [ ! -f "artifacts/windows-client/r-type_client.exe" ]; then
            echo "âŒ Missing Windows client executable (expected: artifacts/windows-client/r-type_client.exe)"
            MISSING=1
          else
            echo "âœ… Found Windows client"
          fi

          if [ ! -f "artifacts/linux-server/r-type_server" ]; then
            echo "âŒ Missing Linux server executable (expected: artifacts/linux-server/r-type_server)"
            MISSING=1
          else
            echo "âœ… Found Linux server"
          fi

          if [ ! -f "artifacts/windows-server/r-type_server.exe" ]; then
            echo "âŒ Missing Windows server executable (expected: artifacts/windows-server/r-type_server.exe)"
            MISSING=1
          else
            echo "âœ… Found Windows server"
          fi

          # Validate plugins are present
          echo ""
          echo "Validating plugins structure..."

          if [ ! -f "artifacts/linux-client/plugins/display.so" ]; then
            echo "âŒ Missing Linux display plugin (expected: artifacts/linux-client/plugins/display.so)"
            MISSING=1
          else
            echo "âœ… Found Linux display plugin"
          fi

          if [ ! -f "artifacts/windows-client/plugins/display.dll" ]; then
            echo "âŒ Missing Windows display plugin (expected: artifacts/windows-client/plugins/display.dll)"
            MISSING=1
          else
            echo "âœ… Found Windows display plugin"
          fi

          if [ -d "artifacts/linux-client/plugins/background" ] && [ "$(ls -A artifacts/linux-client/plugins/background)" ]; then
            echo "âœ… Found Linux background plugins: $(ls artifacts/linux-client/plugins/background)"
          else
            echo "âš ï¸  Warning: No Linux background plugins found (may be expected)"
          fi

          if [ -d "artifacts/windows-client/plugins/background" ] && [ "$(ls -A artifacts/windows-client/plugins/background)" ]; then
            echo "âœ… Found Windows background plugins: $(ls artifacts/windows-client/plugins/background)"
          else
            echo "âš ï¸  Warning: No Windows background plugins found (may be expected)"
          fi

          if [ -d "artifacts/linux-client/plugins/music" ] && [ "$(ls -A artifacts/linux-client/plugins/music)" ]; then
            echo "âœ… Found Linux music plugins: $(ls artifacts/linux-client/plugins/music)"
          else
            echo "âš ï¸  Warning: No Linux music plugins found (may be expected)"
          fi

          if [ -d "artifacts/windows-client/plugins/music" ] && [ "$(ls -A artifacts/windows-client/plugins/music)" ]; then
            echo "âœ… Found Windows music plugins: $(ls artifacts/windows-client/plugins/music)"
          else
            echo "âš ï¸  Warning: No Windows music plugins found (may be expected)"
          fi

          if [ "$MISSING" -ne 0 ]; then
            echo ""
            echo "âŒ One or more required artifacts are missing. This likely means the CI workflow failed to build or upload artifacts."
            echo "Please check the CI workflow run for this branch to ensure all builds completed successfully."
            exit 1
          fi

          echo ""
          echo "âœ… All required artifacts are present with correct plugin structure"

      - name: Prepare release assets
        run: |
          mkdir -p release-packages

          # Package Linux client
          if [ -d "artifacts/linux-client" ]; then
            echo "ðŸ“¦ Packaging Linux client with structure:"
            find artifacts/linux-client -type f | head -20
            cd artifacts/linux-client
            zip -r ../../release-packages/r-type_client-linux.zip .
            cd ../..
            echo "âœ… Packaged Linux client â†’ release-packages/r-type_client-linux.zip"
          fi

          # Package Windows client
          if [ -d "artifacts/windows-client" ]; then
            echo "ðŸ“¦ Packaging Windows client with structure:"
            find artifacts/windows-client -type f | head -20
            cd artifacts/windows-client
            zip -r ../../release-packages/r-type_client-windows.zip .
            cd ../..
            echo "âœ… Packaged Windows client â†’ release-packages/r-type_client-windows.zip"
          fi

          # Package Linux server
          if [ -d "artifacts/linux-server" ]; then
            echo "ðŸ“¦ Packaging Linux server"
            cd artifacts/linux-server
            zip -r ../../release-packages/r-type_server-linux.zip .
            cd ../..
            echo "âœ… Packaged Linux server â†’ release-packages/r-type_server-linux.zip"
          fi

          # Package Windows server
          if [ -d "artifacts/windows-server" ]; then
            echo "ðŸ“¦ Packaging Windows server"
            cd artifacts/windows-server
            zip -r ../../release-packages/r-type_server-windows.zip .
            cd ../..
            echo "âœ… Packaged Windows server â†’ release-packages/r-type_server-windows.zip"
          fi

          # Package assets folder
          if [ -d "assets" ]; then
            echo "ðŸ“¦ Packaging game assets"
            mkdir -p release-packages-temp/assets
            cp -r assets/* release-packages-temp/assets/
            cd release-packages-temp
            zip -r ../release-packages/r-type_assets.zip assets/
            cd ..
            rm -rf release-packages-temp
            echo "âœ… Packaged assets â†’ release-packages/r-type_assets.zip"
          fi

          # Package config folder
          if [ -d "config" ]; then
            echo "ðŸ“¦ Packaging configuration files"
            mkdir -p release-packages-temp/config
            cp -r config/* release-packages-temp/config/
            cd release-packages-temp
            zip -r ../release-packages/r-type_config.zip config/
            cd ..
            rm -rf release-packages-temp
            echo "âœ… Packaged config â†’ release-packages/r-type_config.zip"
          fi

          echo ""
          echo "ðŸ“‹ Release packages created:"
          ls -lh release-packages/
          echo ""
          echo "ðŸ“‹ Client archive contents (first 20 files):"
          unzip -l release-packages/r-type_client-windows.zip | head -25

      - name: Check for new commits since last release
        id: check_commits
        run: |
          LATEST_TAG="${{ steps.latest_release.outputs.latest_tag }}"
          BRANCH="${{ github.ref_name }}"

          echo "Current HEAD: $(git rev-parse HEAD)"
          echo "Current branch: $BRANCH"
          echo "Latest tag: $LATEST_TAG"

          if git rev-parse --verify "$LATEST_TAG" >/dev/null 2>&1; then
            echo "Latest tag commit: $(git rev-parse $LATEST_TAG)"
            NEW_COMMITS=$(git rev-list "${LATEST_TAG}"..HEAD --count)
            echo "New commits since ${LATEST_TAG}: ${NEW_COMMITS}"
          else
            echo "Latest tag not found (likely v0.0.0 default), counting all commits"
            NEW_COMMITS=$(git rev-list HEAD --count)
            echo "Total commits in repository: ${NEW_COMMITS}"
          fi

          if [ "${NEW_COMMITS}" -gt 0 ]; then
            echo "skip=false" >> $GITHUB_OUTPUT
          else
            echo "No new commits since last release, skipping"
            echo "skip=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        id: release_notes
        run: |
          LATEST_TAG="${{ steps.latest_release.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.version.outputs.new_version }}"

          get_username() {
            local email="$1"
            case "$email" in
              "paul-antoine.salmon@epitech.eu") echo "Arkteus" ;;
              "noa.roussiere@epitech.eu") echo "nduboi" ;;
              "samuel.tesson@epitech.eu") echo "SamTess" ;;
              "clement.talneau@epitech.eu") echo "ctalneau" ;;
              *)
                local api_username=$(curl -s "https://api.github.com/search/users?q=${email}" -H "Accept: application/vnd.github.v3+json" | grep -o '"login":"[^"]*' | head -1 | cut -d'"' -f4)
                if [ ! -z "$api_username" ]; then
                  echo "$api_username"
                else
                  echo "$email" | sed 's/@.*//'
                fi
                ;;
            esac
          }

          cat > release_notes.md << 'EOF'
          ## What's Changed

          EOF

          if git rev-parse --verify "$LATEST_TAG" >/dev/null 2>&1; then
            echo "Generating changelog from $LATEST_TAG to HEAD"

            git log ${LATEST_TAG}..HEAD --pretty=format:"%s (%h) - %ae" --reverse | while read line; do
              email=$(echo "$line" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+' | head -1)
              if [ ! -z "$email" ]; then
                username=$(get_username "$email")
                if [ ! -z "$username" ]; then
                  line=$(echo "$line" | sed "s/${email}/@${username}/")
                fi
              fi
              echo "- $line" >> release_notes.md
            done

            echo "" >> release_notes.md
            echo "" >> release_notes.md
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...${NEW_VERSION}" >> release_notes.md
          else
            echo "First release, generating full changelog"
            git log HEAD --pretty=format:"%s (%h) - %ae" --reverse | while read line; do
              email=$(echo "$line" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+' | head -1)
              if [ ! -z "$email" ]; then
                username=$(get_username "$email")
                if [ ! -z "$username" ]; then
                  line=$(echo "$line" | sed "s/${email}/@${username}/")
                fi
              fi
              echo "- $line" >> release_notes.md
            done
            echo "" >> release_notes.md
            echo "" >> release_notes.md
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/commits/${NEW_VERSION}" >> release_notes.md
          fi

          echo "" >> release_notes.md
          echo "## Contributors" >> release_notes.md
          echo "" >> release_notes.md

          if git rev-parse --verify "$LATEST_TAG" >/dev/null 2>&1; then
            git log ${LATEST_TAG}..HEAD --format='%ae' | sort -u | while read email; do
              username=$(get_username "$email")
              echo "- @${username}" >> release_notes.md
            done
          else
            git log HEAD --format='%ae' | sort -u | while read email; do
              username=$(get_username "$email")
              echo "- @${username}" >> release_notes.md
            done
          fi

      - name: Create release with auto-generated notes
        if: steps.check_commits.outputs.skip != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.new_version }}
          name: R-Type ${{ steps.version.outputs.new_version }} (${{ steps.version.outputs.tag_suffix }})
          target_commitish: ${{ github.sha }}
          body_path: release_notes.md
          prerelease: ${{ steps.version.outputs.prerelease }}
          files: |
            release-packages/*.zip