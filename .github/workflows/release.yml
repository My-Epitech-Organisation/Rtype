name: ðŸš€ R-Type Release

on:
  push:
    branches:
      - main
      - dev
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Check branch for manual release
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ "${{ github.ref_name }}" != "main" ]; then
            echo "âŒ Manual releases can only be triggered from the main branch"
            echo "Current branch: ${{ github.ref_name }}"
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Get latest release
        id: latest_release
        run: |
          git fetch --tags --force

          LATEST_TAG=$(git tag -l 'v*' | sort -V | tail -n 1)

          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi

          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest release: $LATEST_TAG"
          echo "All tags found:"
          git tag -l 'v*' | sort -V

      - name: Calculate next version
        id: version
        run: |
          LATEST_TAG="${{ steps.latest_release.outputs.latest_tag }}"
          BRANCH="${{ github.ref_name }}"
          EVENT_NAME="${{ github.event_name }}"

          VERSION="${LATEST_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          echo "Current version: $MAJOR.$MINOR.$PATCH"
          echo "Branch: $BRANCH"
          echo "Event: $EVENT_NAME"

          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            NEW_MAJOR=$((MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
            PRERELEASE=false
            TAG_SUFFIX="release - main"
          elif [ "$BRANCH" = "main" ]; then
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
            PRERELEASE=true
            TAG_SUFFIX="main"
          elif [ "$BRANCH" = "dev" ]; then
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$MINOR
            NEW_PATCH=$((PATCH + 1))
            PRERELEASE=true
            TAG_SUFFIX="dev"
          else
            echo "Unsupported branch for release: $BRANCH"
            exit 1
          fi

          NEW_VERSION="v$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT
          echo "tag_suffix=$TAG_SUFFIX" >> $GITHUB_OUTPUT
      - name: Download Linux client artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          branch: ${{ github.ref_name }}
          name: r-type_client-ubuntu-latest
          path: ./artifacts/linux-client

      - name: Download Windows client artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          branch: ${{ github.ref_name }}
          name: r-type_client-windows-latest
          path: ./artifacts/windows-client

      - name: Download Linux server artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          branch: ${{ github.ref_name }}
          name: r-type_server-ubuntu-latest
          path: ./artifacts/linux-server

      - name: Download Windows server artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          branch: ${{ github.ref_name }}
          name: r-type_server-windows-latest
          path: ./artifacts/windows-server

      - name: Validate downloaded artifacts
        run: |
          echo "ðŸ” Validating downloaded artifacts..."
          echo "Artifact directory structure:"
          find artifacts -type f

          MISSING=0

          if [ ! -f "artifacts/linux-client/r-type_client" ]; then
            echo "âŒ Missing Linux client executable (expected: artifacts/linux-client/r-type_client)"
            MISSING=1
          else
            echo "âœ… Found Linux client"
          fi

          if [ ! -f "artifacts/windows-client/r-type_client.exe" ]; then
            echo "âŒ Missing Windows client executable (expected: artifacts/windows-client/r-type_client.exe)"
            MISSING=1
          else
            echo "âœ… Found Windows client"
          fi

          if [ ! -f "artifacts/linux-server/r-type_server" ]; then
            echo "âŒ Missing Linux server executable (expected: artifacts/linux-server/r-type_server)"
            MISSING=1
          else
            echo "âœ… Found Linux server"
          fi

          if [ ! -f "artifacts/windows-server/r-type_server.exe" ]; then
            echo "âŒ Missing Windows server executable (expected: artifacts/windows-server/r-type_server.exe)"
            MISSING=1
          else
            echo "âœ… Found Windows server"
          fi

          if [ "$MISSING" -ne 0 ]; then
            echo "âŒ One or more required artifacts are missing. This likely means the CI workflow failed to build or upload artifacts."
            echo "Please check the CI workflow run for this branch to ensure all builds completed successfully."
            exit 1
          fi

          echo "âœ… All required artifacts are present"

      - name: Prepare release assets
        run: |
          mkdir -p release-packages

          # Package Linux client
          if [ -d "artifacts/linux-client" ]; then
            cd artifacts/linux-client
            zip -r ../../release-packages/r-type_client-linux.zip .
            cd ../..
            echo "âœ… Packaged Linux client"
          fi

          # Package Windows client
          if [ -d "artifacts/windows-client" ]; then
            cd artifacts/windows-client
            zip -r ../../release-packages/r-type_client-windows.zip .
            cd ../..
            echo "âœ… Packaged Windows client"
          fi

          # Package Linux server
          if [ -d "artifacts/linux-server" ]; then
            cd artifacts/linux-server
            zip -r ../../release-packages/r-type_server-linux.zip .
            cd ../..
            echo "âœ… Packaged Linux server"
          fi

          # Package Windows server
          if [ -d "artifacts/windows-server" ]; then
            cd artifacts/windows-server
            zip -r ../../release-packages/r-type_server-windows.zip .
            cd ../..
            echo "âœ… Packaged Windows server"
          fi

          # Package assets folder (excluding config.toml)
          if [ -d "assets" ]; then
            mkdir -p release-packages-temp/assets
            cp -r assets/* release-packages-temp/assets/
            cd release-packages-temp
            zip -r ../release-packages/r-type_assets.zip assets/
            cd ..
            rm -rf release-packages-temp
            echo "âœ… Packaged assets (without config.toml)"
          fi

          echo ""
          echo "Release packages created:"
          ls -lh release-packages/

      - name: Check for new commits since last release
        id: check_commits
        run: |
          LATEST_TAG="${{ steps.latest_release.outputs.latest_tag }}"
          BRANCH="${{ github.ref_name }}"

          echo "Current HEAD: $(git rev-parse HEAD)"
          echo "Current branch: $BRANCH"
          echo "Latest tag: $LATEST_TAG"

          if git rev-parse --verify "$LATEST_TAG" >/dev/null 2>&1; then
            echo "Latest tag commit: $(git rev-parse $LATEST_TAG)"
            NEW_COMMITS=$(git rev-list "${LATEST_TAG}"..HEAD --count)
            echo "New commits since ${LATEST_TAG}: ${NEW_COMMITS}"
          else
            echo "Latest tag not found (likely v0.0.0 default), counting all commits"
            NEW_COMMITS=$(git rev-list HEAD --count)
            echo "Total commits in repository: ${NEW_COMMITS}"
          fi

          if [ "${NEW_COMMITS}" -gt 0 ]; then
            echo "skip=false" >> $GITHUB_OUTPUT
          else
            echo "No new commits since last release, skipping"
            echo "skip=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        id: release_notes
        run: |
          LATEST_TAG="${{ steps.latest_release.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.version.outputs.new_version }}"

          get_username() {
            local email="$1"
            case "$email" in
              "paul-antoine.salmon@epitech.eu") echo "Arkteus" ;;
              "noa.roussiere@epitech.eu") echo "nduboi" ;;
              "samuel.tesson@epitech.eu") echo "SamTess" ;;
              "clement.talneau@epitech.eu") echo "ctalneau" ;;
              *)
                local api_username=$(curl -s "https://api.github.com/search/users?q=${email}" -H "Accept: application/vnd.github.v3+json" | grep -o '"login":"[^"]*' | head -1 | cut -d'"' -f4)
                if [ ! -z "$api_username" ]; then
                  echo "$api_username"
                else
                  echo "$email" | sed 's/@.*//'
                fi
                ;;
            esac
          }

          cat > release_notes.md << 'EOF'
          ## What's Changed

          EOF

          if git rev-parse --verify "$LATEST_TAG" >/dev/null 2>&1; then
            echo "Generating changelog from $LATEST_TAG to HEAD"

            git log ${LATEST_TAG}..HEAD --pretty=format:"%s (%h) - %ae" --reverse | while read line; do
              email=$(echo "$line" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+' | head -1)
              if [ ! -z "$email" ]; then
                username=$(get_username "$email")
                if [ ! -z "$username" ]; then
                  line=$(echo "$line" | sed "s/${email}/@${username}/")
                fi
              fi
              echo "- $line" >> release_notes.md
            done

            echo "" >> release_notes.md
            echo "" >> release_notes.md
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...${NEW_VERSION}" >> release_notes.md
          else
            echo "First release, generating full changelog"
            git log HEAD --pretty=format:"%s (%h) - %ae" --reverse | while read line; do
              email=$(echo "$line" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+' | head -1)
              if [ ! -z "$email" ]; then
                username=$(get_username "$email")
                if [ ! -z "$username" ]; then
                  line=$(echo "$line" | sed "s/${email}/@${username}/")
                fi
              fi
              echo "- $line" >> release_notes.md
            done
            echo "" >> release_notes.md
            echo "" >> release_notes.md
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/commits/${NEW_VERSION}" >> release_notes.md
          fi

          echo "" >> release_notes.md
          echo "## Contributors" >> release_notes.md
          echo "" >> release_notes.md

          if git rev-parse --verify "$LATEST_TAG" >/dev/null 2>&1; then
            git log ${LATEST_TAG}..HEAD --format='%ae' | sort -u | while read email; do
              username=$(get_username "$email")
              echo "- @${username}" >> release_notes.md
            done
          else
            git log HEAD --format='%ae' | sort -u | while read email; do
              username=$(get_username "$email")
              echo "- @${username}" >> release_notes.md
            done
          fi

      - name: Create release with auto-generated notes
        if: steps.check_commits.outputs.skip != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.new_version }}
          name: R-Type ${{ steps.version.outputs.new_version }} (${{ steps.version.outputs.tag_suffix }})
          target_commitish: ${{ github.sha }}
          body_path: release_notes.md
          prerelease: ${{ steps.version.outputs.prerelease }}
          files: |
            release-packages/*.zip